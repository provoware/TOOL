import pygame, os
class AudioPlayer:
    def __init__(self):
        try:
            pygame.mixer.init()
        except:
            pass
        self.current_file=None; self.is_paused=False; self.volume=0.8
    def load(self,file_path):
        if not os.path.isfile(file_path):
            return "Datei nicht gefunden!"
        try:
            pygame.mixer.music.load(file_path); self.current_file=file_path
            pygame.mixer.music.set_volume(self.volume); self.is_paused=False
            return True
        except Exception as e: return f"Fehler beim Laden: {e}"
    def play(self,file_path=None):
        if file_path and file_path!=self.current_file:
            r=self.load(file_path); 
            if r is not True: return r
        try: pygame.mixer.music.play(); self.is_paused=False; return True
        except Exception as e: return f"Fehler beim Abspielen: {e}"
    def pause(self):
        try:
            if self.is_paused: pygame.mixer.music.unpause(); self.is_paused=False
            else: pygame.mixer.music.pause(); self.is_paused=True
            return True
        except Exception as e: return f"Fehler beim Pausieren: {e}"
    def stop(self):
        try: pygame.mixer.music.stop(); self.is_paused=False; return True
        except Exception as e: return f"Fehler beim Stoppen: {e}"
    def set_volume(self,v):
        try: v=max(0,min(1,float(v))); pygame.mixer.music.set_volume(v); self.volume=v; return True
        except Exception as e: return f"Fehler Lautstärke: {e}"
    def get_status(self):
        if self.is_paused: return "Pause"
        try:
            if pygame.mixer.music.get_busy(): return "Abspielen"
        except: pass
        return "Gestoppt"
import sqlite3, csv, zipfile, os
from log import log_info
def batch_rename(db,ids,prefix='',suffix=''):
    with sqlite3.connect(db) as c:
        for i in ids:
            title=c.execute("SELECT title FROM songs WHERE id=?", (i,)).fetchone()[0]
            c.execute("UPDATE songs SET title=? WHERE id=?", (f'{prefix}{title}{suffix}',i))
    log_info(f'Batch-Rename {len(ids)}'); return True
def batch_genre_change(db,ids,new_gid):
    with sqlite3.connect(db) as c:
        for i in ids: c.execute("UPDATE songs SET genre_id=? WHERE id=?", (new_gid,i))
    log_info(f'Batch-Genre {len(ids)}'); return True
def batch_export(db,ids,out):
    from utils import get_all_songs
    songs=[s for s in get_all_songs(db) if s[0] in ids]
    csvf='songs.csv'
    with open(csvf,'w',newline='',encoding='utf-8') as f:
        w=csv.writer(f); w.writerow(['ID','Title','Text','Genre']); w.writerows([[s[0],s[1],s[2],s[3]] for s in songs])
    with zipfile.ZipFile(out,'w') as z: z.write(csvf)
    os.remove(csvf); log_info(f'Batch-Export {out}'); return True

import PySimpleGUI as sg, os, sys
from audio import AudioPlayer
from utils import init_playlist_db, get_playlist, add_to_playlist, remove_from_playlist,     init_song_db

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PLAYLIST_DB = os.path.join(BASE_DIR,'db','songarchiv_playlist.sqlite3')
SONG_DB = os.path.join(BASE_DIR,'db','songarchiv.sqlite3')

init_playlist_db(PLAYLIST_DB)
init_song_db(SONG_DB)

player = AudioPlayer()

def refresh_playlist(window):
    pl = get_playlist(PLAYLIST_DB)
    window['-LIST-'].update([item['title'] for item in pl])
    return pl

sg.theme('DefaultNoMoreNag')
layout = [
    [sg.Text('Playlist', font=('DejaVu Sans',16,'bold'))],
    [sg.Listbox(values=[], size=(40,10), key='-LIST-', enable_events=True)],
    [sg.Button('Abspielen', key='-PLAY-'), sg.Button('Pause', key='-PAUSE-'),
     sg.Button('Stopp', key='-STOP-')],
    [sg.Button('Hinzufügen'), sg.Button('Entfernen')],
    [sg.Text('Lautstärke'), sg.Slider((0,1), default_value=0.8, resolution=0.05, orientation='h', key='-VOL-', enable_events=True)],
    [sg.StatusBar('Gestoppt', key='-STATUS-')]
]
window = sg.Window('Audio Player', layout, finalize=True)
playlist = refresh_playlist(window)
current_idx = 0

while True:
    ev, vals = window.read(timeout=100)
    if ev in (sg.WINDOW_CLOSED, 'Exit'):
        break
    if ev == '-LIST-':
        sel = vals['-LIST-']
        if sel:
            current_idx = window['-LIST-'].get_indexes()[0]
    if ev == 'Hinzufügen':
        files = sg.popup_get_file('Datei auswählen', multiple_files=True, file_types=(('Audio','*.mp3;*.wav;*.ogg'),))
        if files:
            for f in files.split(';'):
                add_to_playlist(PLAYLIST_DB, f)
            playlist = refresh_playlist(window)
    if ev == 'Entfernen':
        if playlist:
            remove_from_playlist(PLAYLIST_DB, playlist[current_idx]['id'])
            playlist = refresh_playlist(window)
            current_idx = 0
    if ev == '-PLAY-':
        if playlist:
            res = player.play(playlist[current_idx]['file'])
            if res is not True:
                sg.popup_error(res)
    if ev == '-PAUSE-':
        player.toggle_pause()
    if ev == '-STOP-':
        player.stop()
    if ev == '-VOL-':
        player.set_volume(vals['-VOL-'])
    window['-STATUS-'].update(player.status())
window.close()
import logging, os
from logging.handlers import RotatingFileHandler
LOG_DIR='logs'; os.makedirs(LOG_DIR,exist_ok=True)
handler=RotatingFileHandler(os.path.join(LOG_DIR,'app.log'),maxBytes=1_000_000,backupCount=5,encoding='utf-8')
logging.basicConfig(level=logging.DEBUG,handlers=[handler],format='%(asctime)s | %(levelname)-7s | %(message)s')
log_info=lambda m: logging.info(m)
log_debug=lambda m: logging.debug(m)
def log_error(m,e=None): logging.error(f"{m} | {e}" if e else m)
import os
from gui import start_gui
from utils import init_db, get_theme, list_themes

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, "db", "songarchiv.sqlite3")
THEME_DIR = os.path.join(BASE_DIR, "themes")
BACKUP_DIR = os.path.join(BASE_DIR, "db", "backup")

def first_start_setup():
    os.makedirs(os.path.join(BASE_DIR, "db"), exist_ok=True)
    os.makedirs(BACKUP_DIR, exist_ok=True)
    if not os.path.exists(DB_PATH):
        print("Erstelle Datenbank...")
        init_db(DB_PATH)

def main():
    first_start_setup()
    theme_name = "dark"
    theme = get_theme(theme_name, THEME_DIR)
    themes = list_themes(THEME_DIR)
    start_gui(DB_PATH, theme, themes, THEME_DIR, BACKUP_DIR)

if __name__ == "__main__":
    main()
import importlib.util, os, json, shutil, zipfile, hashlib
from log import log_info, log_error
PLUGIN_DIR='plugins'; os.makedirs(PLUGIN_DIR,exist_ok=True)
def scan_and_load(gui=None):
    for folder in os.listdir(PLUGIN_DIR):
        path=os.path.join(PLUGIN_DIR,folder)
        mf=os.path.join(path,'manifest.json')
        if not os.path.isfile(mf): continue
        try:
            info=json.load(open(mf,encoding='utf-8'))
            spec=importlib.util.spec_from_file_location(folder, os.path.join(path,info['entrypoint']))
            mod=importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)
            if hasattr(mod,'register_menu') and gui: mod.register_menu(gui)
            log_info(f"Plugin geladen {folder}")
        except Exception as e: log_error("Plugin-Load",e)
# Plugin- und Update-Manager (Platzhalter)
# SongArchiv Release v4.0.3-r3
PySimpleGUI>=5.0.8,<6
ffmpeg-python
pyenchant
pyttsx3
numpy<2          # 1.26.4 wheel cp312 OK
scipy<1.12       # 1.11.4 wheel cp312 OK
scikit-learn<1.4 # 1.3.2 wheel cp312 OK
sqlite-utils
import sqlite3, datetime, os
from log import log_info
def add_template(db,name,title_tpl,text_tpl,genre=None):
    with sqlite3.connect(db) as c:
        c.execute("INSERT INTO templates(name,title_tpl,text_tpl,genre) VALUES (?,?,?,?)",(name,title_tpl,text_tpl,genre))
    log_info(f"Template gespeichert {name}"); return True
def list_templates(db):
    with sqlite3.connect(db) as c:
        return c.execute("SELECT id,name,title_tpl,text_tpl,genre FROM templates ORDER BY name").fetchall()
def delete_template(db,id):
    with sqlite3.connect(db) as c: c.execute("DELETE FROM templates WHERE id=?", (id,))
    log_info(f'Template gelöscht {id}'); return True
def update_template(db,id,name,title_tpl,text_tpl,genre=None):
    with sqlite3.connect(db) as c:
        c.execute("UPDATE templates SET name=?,title_tpl=?,text_tpl=?,genre=? WHERE id=?",(name,title_tpl,text_tpl,genre,id))
    log_info(f"Template geändert {id}"); return True
def render_template(row,seqnum,user_title=''):
    _id,name,title_tpl,text_tpl,genre=row
    today=datetime.date.today().isoformat()
    ctx={"TITLE":user_title or name,"GENRE":genre or "","DATE":today,"NUM":f'{seqnum:03}'}
    return title_tpl.format(**ctx), text_tpl.format(**ctx), genre

import sqlite3, os
from log import log_info
DB='db/songarchiv.sqlite3'; os.makedirs('db',exist_ok=True)
def get_all_songs(db): 
    with sqlite3.connect(db) as c: 
        c.execute('CREATE TABLE IF NOT EXISTS songs(id INTEGER PRIMARY KEY,title TEXT,text TEXT,genre_id INTEGER)')
        return c.execute('SELECT id,title,text,genre_id FROM songs').fetchall()
